import heapq
import networkx as nx
import matplotlib.pyplot as plt

def dijkstra(graph, start):                                                # Реалізація алгоритму Дейкстри
                                                                           # Ініціалізація словника для зберігання найкоротших шляхів до кожної вершини
    shortest_paths = {vertex: float('infinity') for vertex in graph.nodes}
    shortest_paths[start] = 0
    
    priority_queue = [(0, start)]                                          # Ініціалізація бінарної купи
    
    previous_nodes = {vertex: None for vertex in graph.nodes}              # Словник для зберігання попередніх вершин для відновлення шляху
    
    while priority_queue:                                                  # Отримуємо вершину з найменшою вартістю зі зростаючої купи
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        if current_distance > shortest_paths[current_vertex]:              # Якщо отримана відстань більша, ніж вже відома найкоротша, пропускаємо
            continue
        
        for neighbor, edge_data in graph[current_vertex].items():          # Перевіряємо сусідів поточної вершини
            weight = edge_data['weight']
            distance = current_distance + weight
            
            if distance < shortest_paths[neighbor]:                        # Якщо знайдено коротший шлях до сусідньої вершини
                shortest_paths[neighbor] = distance
                previous_nodes[neighbor] = current_vertex
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return shortest_paths, previous_nodes


def reconstruct_path(previous_nodes, start, end):                          # Функція для відновлення шляху з використанням попередніх вузлів
    path = []
    current = end
    while current is not None:
        path.append(current)
        current = previous_nodes[current]
    path.reverse()
    return path



G = nx.Graph()                                                             # Створюємо граф


edges_with_weights = [                                                     # Додаємо вузли та ребра з вагою до графа
    ("Ковель", "Луцьк", 80), ("Луцьк", "Дубно", 50), ("Дубно", "Тернопіль", 60), ("Тернопіль", "Чернівці", 130),
    ("Львів", "Дубно", 90), ("Дубно", "Рівне", 70), ("Рівне", "Житомир", 100), ("Житомир", "Київ", 130),
    ("Київ", "Полтава", 150), ("Полтава", "Харків", 180),
    ("Ужгород", "Мукачево", 40), ("Мукачево", "Стрий", 90), ("Стрий", "Тернопіль", 110),
    ("Тернопіль", "Хмельницький", 90), ("Хмельницький", "Вінниця", 70), ("Вінниця", "Умань", 110),
    ("Умань", "Кропивницький", 150), ("Кропивницький", "Дніпро", 170), ("Дніпро", "Донецьк", 100),
    ("Донецьк", "Дебальцеве", 60), ("Дебальцеве", "Луганськ", 90),
    ("Чернігів", "Київ", 140), ("Київ", "Біла Церква", 80), ("Біла Церква", "Умань", 120), ("Умань", "Одеса", 190),
    ("Одеса", "Миколаїв", 130), ("Миколаїв", "Херсон", 80), ("Херсон", "Мелітополь", 110), ("Мелітополь", "Маріуполь", 110),
    ("Харків", "Дніпро", 130), ("Дніпро", "Запоріжжя", 80), ("Запоріжжя", "Мелітополь", 90),
    ("Мелітополь", "Джанкой", 130), ("Джанкой", "Сімферополь", 80), ("Сімферополь", "Ялта", 90),
    ("Львів", "Стрий", 50), ("Житомир", "Вінниця", 70), ("Донецьк", "Маріуполь", 90), ("Херсон", "Джанкой", 90),
    ("Харків", "Дебальцеве", 100), ("Полтава", "Кропивницький", 140)
]

G.add_weighted_edges_from(edges_with_weights)


source = "Київ"                                                            # Використання алгоритму Дейкстри для пошуку найкоротших шляхів
shortest_paths, previous_nodes = dijkstra(G, source)

print(f"Найкоротші шляхи від {source}:")                                   # Виведення найкоротших шляхів
for target in G.nodes():
    distance = shortest_paths[target]
    path = reconstruct_path(previous_nodes, source, target)
    print(f"До {target}: {path} з відстанню {distance} км")

pos = {
    "Ковель": (25.1, 51.2), "Луцьк": (25.3, 50.7), "Дубно": (25.7, 50.4), "Тернопіль": (25.6, 49.6),
    "Чернівці": (25.9, 48.3), "Львів": (24.0, 49.8), "Рівне": (26.2, 50.6), "Житомир": (28.7, 50.3),
    "Київ": (30.5, 50.4), "Полтава": (34.5, 49.6), "Харків": (36.2, 50.0), "Ужгород": (22.3, 48.6), 
    "Мукачево": (22.7, 48.4), "Стрий": (23.5, 49.3), "Хмельницький": (27.0, 49.4), 
    "Вінниця": (28.5, 49.2), "Умань": (30.2, 48.7), "Кропивницький": (32.3, 48.5), 
    "Дніпро": (35.0, 48.4), "Донецьк": (37.8, 48.0), "Дебальцеве": (38.4, 48.3), 
    "Луганськ": (39.3, 48.6), "Чернігів": (31.3, 51.5), "Біла Церква": (30.0, 49.8), 
    "Одеса": (30.7, 46.5), "Миколаїв": (31.9, 46.9), "Херсон": (32.6, 46.6), 
    "Мелітополь": (35.3, 46.8), "Маріуполь": (37.5, 47.1), "Запоріжжя": (35.2, 47.8), 
    "Джанкой": (34.4, 45.7), "Сімферополь": (34.1, 44.9), "Ялта": (34.2, 44.5)
}

labels = nx.get_edge_attributes(G, 'weight')
nx.draw(G, pos=pos, with_labels=True, node_color='skyblue', font_weight='medium')
nx.draw_networkx_edge_labels(G, pos=pos, edge_labels=labels)
plt.show()
